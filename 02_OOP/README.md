<!-- doc.py -->
ООП
===

Основы объектно-ориентированного программирования: Класс. Экземпляр класса (объект)
-----------------------------------------------------------------------------------

**ООП** - Объектно-ориентированное программирование

**Класс** -

**Метод** -

Инкапсуляция. Полиморфизм. Интерфейсы. Абстрактные классы
---------------------------------------------------------

**Абстракция** - для создания класса нужно выделить
 из объектов (сущностей) предметной области важные
 с точки зрения решения конкретной (нашей) задачи
 характеристики (отбрасывая остальные).
 **Абстрагирование**.

**Инкапсуляция** (латинский: en capsula) - упаковка данных и функций в единый компонент.
В объектно-ориентированных языках инкапсуляция, как правило, реализуется посредством механизма классов.

**Наследование** - свойство системы, позволяющее описать новый класс на основе уже существующего
с частично или полностью заимствующейся функциональностью (данными и методами).
Класс, от которого производится наследование, называется **базовым**, **родительским** или **суперклассом**.
Новый класс - **потомком**, **наследником** или **производным** классом.

**Полиморфизм** - свойство системы использовать объекты с одинаковым интерфейсом без информации о
типе и внутренней структуре объекта.

Модификаторы public, protected, private, package local
------------------------------------------------------


Объектная модель. Состояние, поведение, индивидуальность (Гради Буч)
--------------------------------------------------------------------

Типы отношений между классами: наследование, аггрегация, ассоциация
-------------------------------------------------------------------

Множественное наследование. Делегирование
-----------------------------------------

Java не поддерживает множественное наследование реализаций (классов).
Это объясняется тем, что такое наследование порождает проблемы.
Чаще всего указываются неоднозначности, возникающие при так называемом "ромбовидном" наследовании,
когда один класс **A** является предком двух других классов **B** и **C**, причем и тот и другой являются предками класса **D**.

Вместо множественного наследования классов в Java есть множественное наследование интерфейсов,
при котором, как утверждается, никаких проблем не возникает.

``` java
    public interface I1 {
        void m1();
    }
```

[src/main/java/multi/Demo.java](src/main/java/multi/Demo.java)

``` java
    // Без модификатора
    // Поле доступно в текущем пакете
    int packageLocal = 1;

    // Только внутри класса A
    private int onlyInA = 2;

    // Внутри класса A и всех наследников A
    // + внутри пакета
    protected int withSubclasses = 3;

    // Доступно всем
    public int forAll = 4;
```

[src/main/java/n_public_private_protected/A.java](src/main/java/n_public_private_protected/A.java)

``` java
public class B extends A {

    void methodB(){
        packageLocal = 10; // Видна везде внутри пакета
        withSubclasses = 20; // Видна так как B - потомок A
        forAll = 30;  // Видна всем
       // onlyInA = 10; // Не видна, т.к. с модификатором public в A
    }
}
```

[src/main/java/n_public_private_protected/B.java](src/main/java/n_public_private_protected/B.java)

